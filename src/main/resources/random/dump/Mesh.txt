//package com.graphics.component;
//
//import com.graphics.component.mesh._3D.FaceMI;
//import com.maths.vectors.Vector2f;
//import com.maths.vectors.Vector3f;
//import com.maths.vectors.Vector3i;
//import com.utils.DataTypeUtils;
//import org.apache.commons.math3.util.FastMath;
//import org.lwjgl.system.MemoryUtil;
//
//import java.nio.FloatBuffer;
//import java.nio.IntBuffer;
//import java.util.List;
//
//import static org.lwjgl.opengl.GL11.*;
//import static org.lwjgl.opengl.GL15.*;
//import static org.lwjgl.opengl.GL20.*;
//import static org.lwjgl.opengl.GL30.*;
//
//public class Mesh {
//
//    private final int vaoId;
//
//    private int vertexPositionsVboId;
//
//    private int vertexNormalsVboId;
//
//    private int textureCoordsVboId;
//
//    private int tangentVboId;
//
//    private int bitangentVboId;
//
//    private int vertexIndicesVboId;
//
//    private final int vertexCount;
//
//    private float boundingSphereRadius;
//
//    private final boolean supportsTexture;
//
//    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    public Mesh(List<Vector3f> vertexPositions, FaceMI[] faces){
//        this(vertexPositions.toArray(new Vector3f[vertexPositions.size()]), null, null, faces);
//    }
//
//    public Mesh(Vector3f[] vertexPositions, List<FaceMI> faces){
//        this(vertexPositions, null, null, faces.toArray(new FaceMI[faces.size()]));
//    }
//
//    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//    public Mesh(List<Vector3f> vertexPositions, List<Vector3f> vertexNormals, List<Vector2f> textureCoordinates, List<FaceMI> faces){
//        this(
//                vertexPositions.toArray(new Vector3f[vertexPositions.size()]),
//                vertexNormals == null || vertexNormals.size() == 0 ? null : vertexNormals.toArray(new Vector3f[vertexNormals.size()]),
//                textureCoordinates == null || textureCoordinates.size() == 0 ? null : textureCoordinates.toArray(new Vector2f[textureCoordinates.size()]),
//                faces.toArray(new FaceMI[faces.size()])
//        );
//    }
//
//    public Mesh(Vector3f[] vertexPositions, Vector3f[] vertexNormals, Vector2f[] textureCoordinates, FaceMI[] faces){
//        supportsTexture = textureCoordinates != null;
//        final boolean needsVertexNormals = vertexNormals == null;
//        final boolean needsTangents = true;
//        calcBoundingSphereRadius(vertexPositions);
//
//        if(needsVertexNormals) {
//            vertexNormals = new Vector3f[vertexPositions.length];
//            for (int i = 0; i < vertexNormals.length; i++) {
//                vertexNormals[i] = new Vector3f();
//            }
//        }
//
//        int primitiveFaceCount = 0;
//
//        for(FaceMI face: faces){
//            if(needsVertexNormals) {
//                int[] vertexIndexs = face.getVertexPositionIndexs();
//
//                Vector3f vA = vertexPositions[face.getVertexPositionIndexs()[0]];
//                Vector3f vB = vertexPositions[face.getVertexPositionIndexs()[1]];
//                Vector3f vC = vertexPositions[face.getVertexPositionIndexs()[2]];
//
//                Vector3f vec1 = Vector3f.Subtract(vB, vA);
//                Vector3f vec2 = Vector3f.Subtract(vC, vA);
//                Vector3f faceNormal = Vector3f.MultiplyCrossProduct(vec1, vec2);
//                faceNormal.normalize();
//
//                for (int i = 0; i < face.getFaceOrder(); i++) {
//                    vertexNormals[vertexIndexs[i]].add(faceNormal);
//                }
//            }
//
//            primitiveFaceCount += face.getPrimtiveFaceCount();
//        }
//
//        vertexCount = primitiveFaceCount * 3;
//
//        Vector3f[] VertexPositions = new Vector3f[vertexCount];
//        Vector3f[] VertexNormals = new Vector3f[vertexCount];
//        Vector2f[] TextureCoords = new Vector2f[vertexCount];
//        Vector3f[] Tangents = new Vector3f[vertexCount];
//        Vector3f[] Bitangents = new Vector3f[vertexCount];
//        Vector3i[] VertexIndices = new Vector3i[primitiveFaceCount];
//
//        int primitiveFaceIndex = 0;
//
//        for(FaceMI face: faces){
//            int[] vertexPositionIndexs = face.getVertexPositionIndexs();
//            int[] textureCoordinateIndexs = face.getTextureCoordinateIndexs();
//            int[] vertexNormalIndexs = needsVertexNormals ? face.getVertexPositionIndexs() : face.getVertexNormalIndexs();
//            int faceOrder = vertexPositionIndexs.length;
//
//            for(int i = 1; i <= faceOrder - 2; i++){
//                final int primitiveFaceIndexOffset = primitiveFaceIndex * 3;
//
//                Vector3f vertexPosition0 = vertexPositions[vertexPositionIndexs[0    ]];
//                Vector3f vertexPosition1 = vertexPositions[vertexPositionIndexs[i    ]];
//                Vector3f vertexPosition2 = vertexPositions[vertexPositionIndexs[i + 1]];
//
//                VertexPositions[primitiveFaceIndexOffset    ] = vertexPosition0;
//                VertexPositions[primitiveFaceIndexOffset + 1] = vertexPosition1;
//                VertexPositions[primitiveFaceIndexOffset + 2] = vertexPosition2;
//
//                if(supportsTexture) {
//
//                    Vector2f textureCoord0 = textureCoordinates[textureCoordinateIndexs[0    ]];
//                    Vector2f textureCoord1 = textureCoordinates[textureCoordinateIndexs[i    ]];
//                    Vector2f textureCoord2 = textureCoordinates[textureCoordinateIndexs[i + 1]];
//
//                    TextureCoords[primitiveFaceIndexOffset    ] = textureCoord0;
//                    TextureCoords[primitiveFaceIndexOffset + 1] = textureCoord1;
//                    TextureCoords[primitiveFaceIndexOffset + 2] = textureCoord2;
//
//                    if(needsTangents) {
//
//                        Vector3f edge1 = Vector3f.Subtract(vertexPosition1, vertexPosition0);
//                        Vector3f edge2 = Vector3f.Subtract(vertexPosition2, vertexPosition0);
//                        Vector2f deltaUV1 = Vector2f.Subtract(textureCoord1, textureCoord0);
//                        Vector2f deltaUV2 = Vector2f.Subtract(textureCoord2, textureCoord0);
//
//                        float f = 1.0f / (deltaUV1.getX() * deltaUV2.getY() - deltaUV2.getX() * deltaUV1.getY());
//
//                        Vector3f tangent = new Vector3f(
//                                f * (deltaUV2.getY() * edge1.getX() - deltaUV1.getY() * edge2.getX()),
//                                f * (deltaUV2.getY() * edge1.getY() - deltaUV1.getY() * edge2.getY()),
//                                f * (deltaUV2.getY() * edge1.getZ() - deltaUV1.getY() * edge2.getZ())
//                        );
//
//                        tangent.normalize();
//
//                        Vector3f bitangent = new Vector3f(
//                                f * (-deltaUV2.getX() * edge1.getX() + deltaUV1.getX() * edge2.getX()),
//                                f * (-deltaUV2.getX() * edge1.getY() + deltaUV1.getX() * edge2.getY()),
//                                f * (-deltaUV2.getX() * edge1.getZ() + deltaUV1.getX() * edge2.getZ())
//                        );
//
//                        bitangent.normalize();
//
//                        Tangents[primitiveFaceIndexOffset] = tangent;
//                        Tangents[primitiveFaceIndexOffset + 1] = tangent;
//                        Tangents[primitiveFaceIndexOffset + 2] = tangent;
//
//                        Bitangents[primitiveFaceIndexOffset] = bitangent;
//                        Bitangents[primitiveFaceIndexOffset + 1] = bitangent;
//                        Bitangents[primitiveFaceIndexOffset + 2] = bitangent;
//                    }else {
//
//                    }
//                }
//
//                VertexNormals[primitiveFaceIndexOffset    ] = vertexNormals[vertexNormalIndexs[0    ]];
//                VertexNormals[primitiveFaceIndexOffset + 1] = vertexNormals[vertexNormalIndexs[i    ]];
//                VertexNormals[primitiveFaceIndexOffset + 2] = vertexNormals[vertexNormalIndexs[i + 1]];
//
//                VertexIndices[primitiveFaceIndex] = new Vector3i(
//                        primitiveFaceIndexOffset + 0,
//                        primitiveFaceIndexOffset + 1,
//                        primitiveFaceIndexOffset + 2
//                );
//
//                primitiveFaceIndex++;
//            }
//        }
//
//        vaoId = glGenVertexArrays();
//        glBindVertexArray(vaoId);
//
//        createVertexPositionsVbo(VertexPositions);
//        createVertexNormalsVbo(VertexNormals);
//        if(supportsTexture) {
//            createTextureCoordsVbo(TextureCoords);
//            createTangentsVbos(Tangents, Bitangents);
//        }
//        createVertexIndicesVbo(VertexIndices);
//
//        glBindBuffer(GL_ARRAY_BUFFER, 0);
//        glBindVertexArray(0);
//    }
//
//    private void createVertexPositionsVbo(Vector3f[] VertexPositions){
//        float[] vertexPositions = DataTypeUtils.toFloatArray(VertexPositions);
//        FloatBuffer vertexPositionsBuffer = null;
//
//        try {
//            // Position VBO
//            vertexPositionsVboId = glGenBuffers();
//            vertexPositionsBuffer = MemoryUtil.memAllocFloat(vertexPositions.length);
//            vertexPositionsBuffer.put(vertexPositions).flip();
//            glBindBuffer(GL_ARRAY_BUFFER, vertexPositionsVboId);
//            glBufferData(GL_ARRAY_BUFFER, vertexPositionsBuffer, GL_STATIC_DRAW);
//            glVertexAttribPointer(0, 3, GL_FLOAT, false, 0, 0);
//        }finally {
//            if (vertexPositionsBuffer != null) {
//                MemoryUtil.memFree(vertexPositionsBuffer);
//            }
//        }
//    }
//
//    private void createVertexNormalsVbo(Vector3f[] VertexNormals){
//        float[] vertexNormals = DataTypeUtils.toFloatArray(VertexNormals);
//        FloatBuffer vertexNormalsBuffer = null;
//
//        try {
//            // Vertex normals VBO
//            vertexNormalsVboId = glGenBuffers();
//            vertexNormalsBuffer = MemoryUtil.memAllocFloat(vertexNormals.length);
//            vertexNormalsBuffer.put(vertexNormals).flip();
//            glBindBuffer(GL_ARRAY_BUFFER, vertexNormalsVboId);
//            glBufferData(GL_ARRAY_BUFFER, vertexNormalsBuffer, GL_STATIC_DRAW);
//            glVertexAttribPointer(1, 3, GL_FLOAT, false, 0, 0);
//        }finally {
//            if (vertexNormalsBuffer != null) {
//                MemoryUtil.memFree(vertexNormalsBuffer);
//            }
//        }
//    }
//
//    private void createTextureCoordsVbo(Vector2f[] TextureCoords){
//        float[] textureCoords = DataTypeUtils.toFloatArray(TextureCoords);
//        FloatBuffer textureCoordsBuffer = null;
//
//        try {
//            // Texture coords VBO
//            textureCoordsVboId = glGenBuffers();
//            textureCoordsBuffer = MemoryUtil.memAllocFloat(textureCoords.length);
//            textureCoordsBuffer.put(textureCoords).flip();
//            glBindBuffer(GL_ARRAY_BUFFER, textureCoordsVboId);
//            glBufferData(GL_ARRAY_BUFFER, textureCoordsBuffer, GL_STATIC_DRAW);
//            glVertexAttribPointer(2, 2, GL_FLOAT, false, 0, 0);
//        }finally {
//            if (textureCoordsBuffer != null) {
//                MemoryUtil.memFree(textureCoordsBuffer);
//            }
//        }
//    }
//
//    private void createTangentsVbos(Vector3f[] Tangents, Vector3f[] Bitangents) {
//        float[] tangents = DataTypeUtils.toFloatArray(Tangents);
//        FloatBuffer tangentsBuffer = null;
//        float[] bitangents = DataTypeUtils.toFloatArray(Bitangents);
//        FloatBuffer bitangentsBuffer = null;
//
//        try {
//            // Tangents VBO
//            tangentVboId = glGenBuffers();
//            tangentsBuffer = MemoryUtil.memAllocFloat(tangents.length);
//            tangentsBuffer.put(tangents).flip();
//            glBindBuffer(GL_ARRAY_BUFFER, tangentVboId);
//            glBufferData(GL_ARRAY_BUFFER, tangentsBuffer, GL_STATIC_DRAW);
//            glVertexAttribPointer(3, 3, GL_FLOAT, false, 0, 0);
//
//            // Bitangents VBO
//            bitangentVboId = glGenBuffers();
//            bitangentsBuffer = MemoryUtil.memAllocFloat(bitangents.length);
//            bitangentsBuffer.put(bitangents).flip();
//            glBindBuffer(GL_ARRAY_BUFFER, bitangentVboId);
//            glBufferData(GL_ARRAY_BUFFER, bitangentsBuffer, GL_STATIC_DRAW);
//            glVertexAttribPointer(4, 3, GL_FLOAT, false, 0, 0);
//        }finally {
//            if (tangentsBuffer != null) {
//                MemoryUtil.memFree(tangentsBuffer);
//            }
//
//            if (bitangents != null) {
//                MemoryUtil.memFree(bitangentsBuffer);
//            }
//        }
//    }
//
//    private void createVertexIndicesVbo(Vector3i[] VertexIndices){
//        int[] vertexIndices = DataTypeUtils.toIntArray(VertexIndices);
//        IntBuffer vertexIndicesBuffer = null;
//
//        try {
//            // Index VBO
//            vertexIndicesVboId = glGenBuffers();
//            vertexIndicesBuffer = MemoryUtil.memAllocInt(vertexIndices.length);
//            vertexIndicesBuffer.put(vertexIndices).flip();
//            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vertexIndicesVboId);
//            glBufferData(GL_ELEMENT_ARRAY_BUFFER, vertexIndicesBuffer, GL_STATIC_DRAW);
//
//            glBindBuffer(GL_ARRAY_BUFFER, 0);
//            glBindVertexArray(0);
//        }finally {
//            if (vertexIndicesBuffer != null) {
//                MemoryUtil.memFree(vertexIndicesBuffer);
//            }
//        }
//    }
//
//    public void render(){
//        // Bind vertex data
//        glBindVertexArray(vaoId);
//        glEnableVertexAttribArray(0);
//        glEnableVertexAttribArray(1);
//        if(supportsTexture) {
//            glEnableVertexAttribArray(2);
//            glEnableVertexAttribArray(3);
//            glEnableVertexAttribArray(4);
//        }
//
//        // Draw the mesh
//        glDrawElements(GL_TRIANGLES, vertexCount, GL_UNSIGNED_INT, 0);
//
//        // Restore state
//        glDisableVertexAttribArray(0);
//        glDisableVertexAttribArray(1);
//        if(supportsTexture) {
//            glDisableVertexAttribArray(2);
//            glDisableVertexAttribArray(3);
//            glDisableVertexAttribArray(4);
//        }
//        glBindVertexArray(0);
//    }
//
//    public void dispose() {
//        // Disable the VAO
//        glBindBuffer(GL_ARRAY_BUFFER, 0);
//        glDisableVertexAttribArray(0);
//
//        // Delete the VBOs
//        glDeleteBuffers(vertexPositionsVboId);
//        glDeleteBuffers(vertexNormalsVboId);
//        if(supportsTexture) {
//            glDeleteBuffers(textureCoordsVboId);
//            glDeleteBuffers(tangentVboId);
//            glDeleteBuffers(bitangentVboId);
//        }
//        glDeleteBuffers(vertexIndicesVboId);
//
//        // Delete the VAO
//        glBindVertexArray(0);
//        glDeleteVertexArrays(vaoId);
//    }
//
//    public void calcBoundingSphereRadius(Vector3f[] vertexPositions){
//        for(Vector3f vertex: vertexPositions) {
//            boundingSphereRadius = FastMath.max(boundingSphereRadius, vertex.getLength());
//        }
//    }
//
//    public float getBoundingSphereRadius() {
//        return boundingSphereRadius;
//    }
//
//    public boolean supportsTexture(){
//        return supportsTexture;
//    }
//}
